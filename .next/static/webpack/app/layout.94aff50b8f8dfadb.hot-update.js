"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/shared/api/api-client.ts":
/*!**************************************!*\
  !*** ./src/shared/api/api-client.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: () => (/* binding */ ApiClient),\n/* harmony export */   apiClient: () => (/* binding */ apiClient)\n/* harmony export */ });\nconst API_BASE_URL = 'http://192.168.0.113:5107';\nclass ApiClient {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const url = \"\".concat(this.baseUrl).concat(endpoint);\n        const defaultHeaders = {\n            'Content-Type': 'application/json'\n        };\n        // Agregar token si existe\n        const token =  true ? localStorage.getItem('auth_token') : 0;\n        if (token) {\n            defaultHeaders['Authorization'] = \"Bearer \".concat(token);\n        }\n        const config = {\n            ...options,\n            headers: {\n                ...defaultHeaders,\n                ...options.headers\n            }\n        };\n        try {\n            const response = await fetch(url, config);\n            // Intentar parsear la respuesta siempre\n            let data;\n            const contentType = response.headers.get('content-type');\n            try {\n                if (contentType && contentType.includes('application/json')) {\n                    data = await response.json();\n                } else {\n                    const text = await response.text();\n                    if (text) {\n                        try {\n                            data = JSON.parse(text);\n                        } catch (e) {\n                            data = {\n                                message: text || response.statusText\n                            };\n                        }\n                    } else {\n                        data = {\n                            message: response.statusText || 'Error en la solicitud'\n                        };\n                    }\n                }\n            } catch (parseError) {\n                data = {\n                    message: response.statusText || 'Error en la solicitud'\n                };\n            }\n            // Si la respuesta no es OK, lanzar error\n            // PERO: si es un 401 y hay datos (token/user), puede ser que la API use 401 para indicar algo\n            // En ese caso, devolvemos los datos y dejamos que el auth-provider decida\n            if (!response.ok) {\n                // Si es 401 pero hay token o user en la respuesta, devolver los datos\n                // (algunas APIs usan 401 incluso cuando hay token)\n                if (response.status === 401 && (data.token || data.accessToken || data.jwt || data.user || data.data)) {\n                    return data;\n                }\n                let errorMessage = data.message || data.error || data.errorMessage || data.detail || response.statusText || 'Error en la solicitud';\n                // Detectar el tipo de error basado en el mensaje o código\n                let errorType = undefined;\n                const errorCode = data.code || data.errorCode || '';\n                const lowerMessage = errorMessage.toLowerCase();\n                // Detectar si el usuario no está registrado\n                if (response.status === 404 || lowerMessage.includes('no encontrado') || lowerMessage.includes('not found') || lowerMessage.includes('no existe') || lowerMessage.includes('no registrado') || lowerMessage.includes('usuario no encontrado') || lowerMessage.includes('user not found') || errorCode.includes('USER_NOT_FOUND') || errorCode.includes('NOT_FOUND')) {\n                    errorType = 'user_not_registered';\n                    errorMessage = 'Este email no está registrado en el sistema';\n                } else if (response.status === 401 || lowerMessage.includes('incorrect') || lowerMessage.includes('invalid') || lowerMessage.includes('wrong') || lowerMessage.includes('credenciales') || lowerMessage.includes('contraseña') || lowerMessage.includes('password') || errorCode.includes('INVALID_CREDENTIALS') || errorCode.includes('UNAUTHORIZED')) {\n                    errorType = 'invalid_credentials';\n                    // Si el mensaje no es específico, usar uno genérico\n                    if (!lowerMessage.includes('email') && !lowerMessage.includes('contraseña') && !lowerMessage.includes('password')) {\n                        errorMessage = 'Email o contraseña incorrectos';\n                    }\n                } else if (response.status === 401) {\n                    errorType = 'unauthorized';\n                    errorMessage = errorMessage || 'No autorizado';\n                } else if (response.status === 404) {\n                    errorMessage = errorMessage || 'Endpoint no encontrado';\n                } else if (response.status === 500) {\n                    errorMessage = errorMessage || 'Error interno del servidor';\n                }\n                throw {\n                    message: errorMessage,\n                    status: response.status,\n                    code: errorCode,\n                    type: errorType\n                };\n            }\n            return data;\n        } catch (error) {\n            if (error && typeof error === 'object' && 'message' in error && 'status' in error) {\n                throw error;\n            }\n            throw {\n                message: 'Error de conexión. Verifica tu conexión a internet.',\n                status: 0\n            };\n        }\n    }\n    async get(endpoint, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: 'GET'\n        });\n    }\n    async post(endpoint, data, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: 'POST',\n            body: data ? JSON.stringify(data) : undefined\n        });\n    }\n    async put(endpoint, data, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: 'PUT',\n            body: data ? JSON.stringify(data) : undefined\n        });\n    }\n    async delete(endpoint, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: 'DELETE'\n        });\n    }\n    constructor(baseUrl = API_BASE_URL){\n        this.baseUrl = baseUrl;\n    }\n}\nconst apiClient = new ApiClient();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvYXBpL2FwaS1jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxlQUFlO0FBU2QsTUFBTUM7SUFPWCxNQUFjQyxRQUNaQyxRQUFnQixFQUVKO1lBRFpDLFVBQUFBLGlFQUF1QixDQUFDO1FBRXhCLE1BQU1DLE1BQU0sR0FBa0JGLE9BQWYsSUFBSSxDQUFDRyxPQUFPLEVBQVksT0FBVEg7UUFFOUIsTUFBTUksaUJBQThCO1lBQ2xDLGdCQUFnQjtRQUNsQjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNQyxRQUFRLEtBQTZCLEdBQ3ZDQyxhQUFhQyxPQUFPLENBQUMsZ0JBQ3JCLENBQUk7UUFFUixJQUFJRixPQUFPO1lBQ1RELGNBQWMsQ0FBQyxnQkFBZ0IsR0FBRyxVQUFnQixPQUFOQztRQUM5QztRQUVBLE1BQU1HLFNBQXNCO1lBQzFCLEdBQUdQLE9BQU87WUFDVlEsU0FBUztnQkFDUCxHQUFHTCxjQUFjO2dCQUNqQixHQUFHSCxRQUFRUSxPQUFPO1lBQ3BCO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNVCxLQUFLTTtZQUVsQyx3Q0FBd0M7WUFDeEMsSUFBSUk7WUFDSixNQUFNQyxjQUFjSCxTQUFTRCxPQUFPLENBQUNLLEdBQUcsQ0FBQztZQUV6QyxJQUFJO2dCQUNGLElBQUlELGVBQWVBLFlBQVlFLFFBQVEsQ0FBQyxxQkFBcUI7b0JBQzNESCxPQUFPLE1BQU1GLFNBQVNNLElBQUk7Z0JBQzVCLE9BQU87b0JBQ0wsTUFBTUMsT0FBTyxNQUFNUCxTQUFTTyxJQUFJO29CQUNoQyxJQUFJQSxNQUFNO3dCQUNSLElBQUk7NEJBQ0ZMLE9BQU9NLEtBQUtDLEtBQUssQ0FBQ0Y7d0JBQ3BCLEVBQUUsVUFBTTs0QkFDTkwsT0FBTztnQ0FBRVEsU0FBU0gsUUFBUVAsU0FBU1csVUFBVTs0QkFBQzt3QkFDaEQ7b0JBQ0YsT0FBTzt3QkFDTFQsT0FBTzs0QkFBRVEsU0FBU1Ys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cUMsUUFBUTtRQUFNO0lBQy9EO0lBRUEsTUFBTUMsS0FBUXZDLFFBQWdCLEVBQUVZLElBQVUsRUFBRVgsT0FBcUIsRUFBYztRQUM3RSxPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFJQyxVQUFVO1lBQy9CLEdBQUdDLE9BQU87WUFDVnFDLFFBQVE7WUFDUkUsTUFBTTVCLE9BQU9NLEtBQUt1QixTQUFTLENBQUM3QixRQUFRb0I7UUFDdEM7SUFDRjtJQUVBLE1BQU1VLElBQU8xQyxRQUFnQixFQUFFWSxJQUFVLEVBQUVYLE9BQXFCLEVBQWM7UUFDNUUsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBSUMsVUFBVTtZQUMvQixHQUFHQyxPQUFPO1lBQ1ZxQyxRQUFRO1lBQ1JFLE1BQU01QixPQUFPTSxLQUFLdUIsU0FBUyxDQUFDN0IsUUFBUW9CO1FBQ3RDO0lBQ0Y7SUFFQSxNQUFNVyxPQUFVM0MsUUFBZ0IsRUFBRUMsT0FBcUIsRUFBYztRQUNuRSxPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFJQyxVQUFVO1lBQUUsR0FBR0MsT0FBTztZQUFFcUMsUUFBUTtRQUFTO0lBQ2xFO0lBcEtBLFlBQVluQyxVQUFrQk4sWUFBWSxDQUFFO1FBQzFDLElBQUksQ0FBQ00sT0FBTyxHQUFHQTtJQUNqQjtBQW1LRjtBQUVPLE1BQU15QyxZQUFZLElBQUk5QyxZQUFZIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhbmllXFxPbmVEcml2ZVxcRGVza3RvcFxcUFdBIFZlbmRlZG9yZXNcXHNyY1xcc2hhcmVkXFxhcGlcXGFwaS1jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQVBJX0JBU0VfVVJMID0gJ2h0dHA6Ly8xOTIuMTY4LjAuMTEzOjUxMDcnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBcGlFcnJvciB7XHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIHN0YXR1cz86IG51bWJlcjtcclxuICBjb2RlPzogc3RyaW5nO1xyXG4gIHR5cGU/OiAnbm90X2ZvdW5kJyB8ICd1bmF1dGhvcml6ZWQnIHwgJ2ludmFsaWRfY3JlZGVudGlhbHMnIHwgJ3VzZXJfbm90X3JlZ2lzdGVyZWQnO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXBpQ2xpZW50IHtcclxuICBwcml2YXRlIGJhc2VVcmw6IHN0cmluZztcclxuXHJcbiAgY29uc3RydWN0b3IoYmFzZVVybDogc3RyaW5nID0gQVBJX0JBU0VfVVJMKSB7XHJcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0PFQ+KFxyXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcclxuICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cclxuICApOiBQcm9taXNlPFQ+IHtcclxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2VuZHBvaW50fWA7XHJcbiAgICBcclxuICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQWdyZWdhciB0b2tlbiBzaSBleGlzdGVcclxuICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgXHJcbiAgICAgID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKSBcclxuICAgICAgOiBudWxsO1xyXG4gICAgXHJcbiAgICBpZiAodG9rZW4pIHtcclxuICAgICAgZGVmYXVsdEhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpZzogUmVxdWVzdEluaXQgPSB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAuLi5kZWZhdWx0SGVhZGVycyxcclxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBjb25maWcpO1xyXG4gICAgICBcclxuICAgICAgLy8gSW50ZW50YXIgcGFyc2VhciBsYSByZXNwdWVzdGEgc2llbXByZVxyXG4gICAgICBsZXQgZGF0YTogYW55O1xyXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcclxuICAgICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcclxuICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHRleHQpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICBkYXRhID0geyBtZXNzYWdlOiB0ZXh0IHx8IHJlc3BvbnNlLnN0YXR1c1RleHQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YSA9IHsgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCAnRXJyb3IgZW4gbGEgc29saWNpdHVkJyB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xyXG4gICAgICAgIGRhdGEgPSB7IG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQgfHwgJ0Vycm9yIGVuIGxhIHNvbGljaXR1ZCcgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU2kgbGEgcmVzcHVlc3RhIG5vIGVzIE9LLCBsYW56YXIgZXJyb3JcclxuICAgICAgLy8gUEVSTzogc2kgZXMgdW4gNDAxIHkgaGF5IGRhdG9zICh0b2tlbi91c2VyKSwgcHVlZGUgc2VyIHF1ZSBsYSBBUEkgdXNlIDQwMSBwYXJhIGluZGljYXIgYWxnb1xyXG4gICAgICAvLyBFbiBlc2UgY2FzbywgZGV2b2x2ZW1vcyBsb3MgZGF0b3MgeSBkZWphbW9zIHF1ZSBlbCBhdXRoLXByb3ZpZGVyIGRlY2lkYVxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgLy8gU2kgZXMgNDAxIHBlcm8gaGF5IHRva2VuIG8gdXNlciBlbiBsYSByZXNwdWVzdGEsIGRldm9sdmVyIGxvcyBkYXRvc1xyXG4gICAgICAgIC8vIChhbGd1bmFzIEFQSXMgdXNhbiA0MDEgaW5jbHVzbyBjdWFuZG8gaGF5IHRva2VuKVxyXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSAmJiAoZGF0YS50b2tlbiB8fCBkYXRhLmFjY2Vzc1Rva2VuIHx8IGRhdGEuand0IHx8IGRhdGEudXNlciB8fCBkYXRhLmRhdGEpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YSBhcyBUO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZGF0YS5tZXNzYWdlIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZXJyb3IgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lcnJvck1lc3NhZ2UgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAnRXJyb3IgZW4gbGEgc29saWNpdHVkJztcclxuICAgICAgICBcclxuICAgICAgICAvLyBEZXRlY3RhciBlbCB0aXBvIGRlIGVycm9yIGJhc2FkbyBlbiBlbCBtZW5zYWplIG8gY8OzZGlnb1xyXG4gICAgICAgIGxldCBlcnJvclR5cGU6IEFwaUVycm9yWyd0eXBlJ10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZGF0YS5jb2RlIHx8IGRhdGEuZXJyb3JDb2RlIHx8ICcnO1xyXG4gICAgICAgIGNvbnN0IGxvd2VyTWVzc2FnZSA9IGVycm9yTWVzc2FnZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERldGVjdGFyIHNpIGVsIHVzdWFyaW8gbm8gZXN0w6EgcmVnaXN0cmFkb1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCB8fCBcclxuICAgICAgICAgICAgbG93ZXJNZXNzYWdlLmluY2x1ZGVzKCdubyBlbmNvbnRyYWRvJykgfHwgXHJcbiAgICAgICAgICAgIGxvd2VyTWVzc2FnZS5pbmNsdWRlcygnbm90IGZvdW5kJykgfHxcclxuICAgICAgICAgICAgbG93ZXJNZXNzYWdlLmluY2x1ZGVzKCdubyBleGlzdGUnKSB8fFxyXG4gICAgICAgICAgICBsb3dlck1lc3NhZ2UuaW5jbHVkZXMoJ25vIHJlZ2lzdHJhZG8nKSB8fFxyXG4gICAgICAgICAgICBsb3dlck1lc3NhZ2UuaW5jbHVkZXMoJ3VzdWFyaW8gbm8gZW5jb250cmFkbycpIHx8XHJcbiAgICAgICAgICAgIGxvd2VyTWVzc2FnZS5pbmNsdWRlcygndXNlciBub3QgZm91bmQnKSB8fFxyXG4gICAgICAgICAgICBlcnJvckNvZGUuaW5jbHVkZXMoJ1VTRVJfTk9UX0ZPVU5EJykgfHxcclxuICAgICAgICAgICAgZXJyb3JDb2RlLmluY2x1ZGVzKCdOT1RfRk9VTkQnKSkge1xyXG4gICAgICAgICAgZXJyb3JUeXBlID0gJ3VzZXJfbm90X3JlZ2lzdGVyZWQnO1xyXG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ0VzdGUgZW1haWwgbm8gZXN0w6EgcmVnaXN0cmFkbyBlbiBlbCBzaXN0ZW1hJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGV0ZWN0YXIgY3JlZGVuY2lhbGVzIGluY29ycmVjdGFzXHJcbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHwgXHJcbiAgICAgICAgICAgICAgICAgbG93ZXJNZXNzYWdlLmluY2x1ZGVzKCdpbmNvcnJlY3QnKSB8fFxyXG4gICAgICAgICAgICAgICAgIGxvd2VyTWVzc2FnZS5pbmNsdWRlcygnaW52YWxpZCcpIHx8XHJcbiAgICAgICAgICAgICAgICAgbG93ZXJNZXNzYWdlLmluY2x1ZGVzKCd3cm9uZycpIHx8XHJcbiAgICAgICAgICAgICAgICAgbG93ZXJNZXNzYWdlLmluY2x1ZGVzKCdjcmVkZW5jaWFsZXMnKSB8fFxyXG4gICAgICAgICAgICAgICAgIGxvd2VyTWVzc2FnZS5pbmNsdWRlcygnY29udHJhc2XDsWEnKSB8fFxyXG4gICAgICAgICAgICAgICAgIGxvd2VyTWVzc2FnZS5pbmNsdWRlcygncGFzc3dvcmQnKSB8fFxyXG4gICAgICAgICAgICAgICAgIGVycm9yQ29kZS5pbmNsdWRlcygnSU5WQUxJRF9DUkVERU5USUFMUycpIHx8XHJcbiAgICAgICAgICAgICAgICAgZXJyb3JDb2RlLmluY2x1ZGVzKCdVTkFVVEhPUklaRUQnKSkge1xyXG4gICAgICAgICAgZXJyb3JUeXBlID0gJ2ludmFsaWRfY3JlZGVudGlhbHMnO1xyXG4gICAgICAgICAgLy8gU2kgZWwgbWVuc2FqZSBubyBlcyBlc3BlY8OtZmljbywgdXNhciB1bm8gZ2Vuw6lyaWNvXHJcbiAgICAgICAgICBpZiAoIWxvd2VyTWVzc2FnZS5pbmNsdWRlcygnZW1haWwnKSAmJiAhbG93ZXJNZXNzYWdlLmluY2x1ZGVzKCdjb250cmFzZcOxYScpICYmICFsb3dlck1lc3NhZ2UuaW5jbHVkZXMoJ3Bhc3N3b3JkJykpIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ0VtYWlsIG8gY29udHJhc2XDsWEgaW5jb3JyZWN0b3MnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdHJvcyBlcnJvcmVzIDQwMVxyXG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XHJcbiAgICAgICAgICBlcnJvclR5cGUgPSAndW5hdXRob3JpemVkJztcclxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCAnTm8gYXV0b3JpemFkbyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVycm9yIDQwNCBnZW7DqXJpY29cclxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlIHx8ICdFbmRwb2ludCBubyBlbmNvbnRyYWRvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXJyb3IgNTAwXHJcbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcclxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCAnRXJyb3IgaW50ZXJubyBkZWwgc2Vydmlkb3InO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXHJcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcclxuICAgICAgICAgIHR5cGU6IGVycm9yVHlwZSxcclxuICAgICAgICB9IGFzIEFwaUVycm9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0YSBhcyBUO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ21lc3NhZ2UnIGluIGVycm9yICYmICdzdGF0dXMnIGluIGVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3IgYXMgQXBpRXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cge1xyXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBkZSBjb25leGnDs24uIFZlcmlmaWNhIHR1IGNvbmV4acOzbiBhIGludGVybmV0LicsXHJcbiAgICAgICAgc3RhdHVzOiAwLFxyXG4gICAgICB9IGFzIEFwaUVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8VD4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwgeyAuLi5vcHRpb25zLCBtZXRob2Q6ICdHRVQnIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcG9zdDxUPihlbmRwb2ludDogc3RyaW5nLCBkYXRhPzogYW55LCBvcHRpb25zPzogUmVxdWVzdEluaXQpOiBQcm9taXNlPFQ+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcHV0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIGRhdGE/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8VD4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBib2R5OiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiB1bmRlZmluZWQsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZTxUPihlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdEluaXQpOiBQcm9taXNlPFQ+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsIHsgLi4ub3B0aW9ucywgbWV0aG9kOiAnREVMRVRFJyB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KCk7XHJcbiJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJBcGlDbGllbnQiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidXJsIiwiYmFzZVVybCIsImRlZmF1bHRIZWFkZXJzIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY29uZmlnIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwiY29udGVudFR5cGUiLCJnZXQiLCJpbmNsdWRlcyIsImpzb24iLCJ0ZXh0IiwiSlNPTiIsInBhcnNlIiwibWVzc2FnZSIsInN0YXR1c1RleHQiLCJwYXJzZUVycm9yIiwib2siLCJzdGF0dXMiLCJhY2Nlc3NUb2tlbiIsImp3dCIsInVzZXIiLCJlcnJvck1lc3NhZ2UiLCJlcnJvciIsImRldGFpbCIsImVycm9yVHlwZSIsInVuZGVmaW5lZCIsImVycm9yQ29kZSIsImNvZGUiLCJsb3dlck1lc3NhZ2UiLCJ0b0xvd2VyQ2FzZSIsInR5cGUiLCJtZXRob2QiLCJwb3N0IiwiYm9keSIsInN0cmluZ2lmeSIsInB1dCIsImRlbGV0ZSIsImFwaUNsaWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/api/api-client.ts\n"));

/***/ })

});